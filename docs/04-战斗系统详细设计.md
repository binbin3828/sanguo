# 三国霸业 - 战斗系统详细设计文档

## 文档说明

本文档详细描述《三国霸业》战斗系统的所有机制、算法和数值计算，包括战旗移动、攻击计算、技能系统和AI行为。

---

## 一、战斗系统总览

### 1.1 战斗触发条件

战斗在以下情况触发：
- 玩家执行"出征"指令进攻敌方城市
- 敌方势力进攻玩家城市（自动战斗或手动战斗）
- 剧情触发的特殊战斗

### 1.2 战斗规模

- **进攻方**：最多10名武将
- **防守方**：最多10名武将
- **总参战人数**：最多20名武将

### 1.3 战斗流程

```
战斗初始化 → 回合开始（第1-30天）→ 玩家行动 → AI行动 → 回合结束 → 胜负判定
                    ↓
              重复直到一方全灭/粮草耗尽/30天结束
```

### 1.4 战斗结束条件

| 结束条件 | 进攻方结果 | 防守方结果 |
|----------|------------|------------|
| 一方全灭 | 胜利 | 失败 |
| 主将阵亡 | 失败 | 胜利 |
| 粮草耗尽 | 失败 | 胜利 |
| 30天结束 | 失败 | 胜利 |
| 占领城池 | 胜利 | 失败 |

---

## 二、战斗初始化

### 2.1 战斗参数

```typescript
interface BattleParams {
  mode: number;           // 0=防守, 1=进攻, 2=AI vs AI
  way: number;            // 进攻方向 0-7
  mapId: number;          // 地图ID
  mProvender: number;     // 玩家方粮草
  eProvender: number;     // 敌方粮草
  genArray: number[];     // 参战武将ID [20]
  cityIndex: number;      // 战斗城市
}
```

### 2.2 地图系统

**地图尺寸**：
- 最大宽度：256
- 最大高度：256
- 图块大小：16x16像素

**地形类型**：

| 编号 | 地形 | 移动力消耗 | 防御加成 |
|------|------|------------|----------|
| 0 | 草地 | 2 | 1.0 |
| 1 | 平原 | 1 | 1.0 |
| 2 | 山地 | 3 | 1.3 |
| 3 | 森林 | 3 | 1.15 |
| 4 | 村庄 | 2 | 1.1 |
| 5 | 城池 | 4 | 1.5 |
| 6 | 营寨 | 2 | 1.2 |
| 7 | 河流 | 4 | 0.8 |

### 2.3 初始位置设定

根据进攻方向，双方初始位置不同：

```typescript
function calculateInitialPositions(way: number, isAttacker: boolean): Position {
  // 8个方向：北(0),东北(1),东(2),东南(3),南(4),西南(5),西(6),西北(7)
  const basePositions = [
    { x: centerX, y: 0 },          // 北
    { x: mapWidth-5, y: 2 },       // 东北
    { x: mapWidth-5, y: centerY }, // 东
    { x: mapWidth-5, y: mapHeight-5 }, // 东南
    { x: centerX, y: mapHeight-5 },// 南
    { x: 2, y: mapHeight-5 },      // 西南
    { x: 2, y: centerY },          // 西
    { x: 0, y: 0 }                 // 西北
  ];
  
  return basePositions[way];
}
```

### 2.4 将领属性计算

**生命值（HP）计算**：
```typescript
function calculateHP(person: PersonType): number {
  // HP = (武力 * 0.8 + 智力 * 0.3 + 等级) * 体力 / 100
  let baseHP = (person.force * 0.8 + person.iq * 0.3 + person.level);
  return Math.floor(baseHP * person.thew / 100);
}
```

**技能点（MP）计算**：
```typescript
function calculateMP(person: PersonType): number {
  // MP = (智力 * 0.8 + √武力 / 2 + 等级) * 体力 / 100
  let baseMP = (person.iq * 0.8 + Math.sqrt(person.force) / 2 + person.level);
  return Math.floor(baseMP * person.thew / 100);
}
```

**移动力计算**：
```typescript
const ARMY_MOVE_BASE = [5, 4, 4, 5, 6, 3]; // 骑兵,步兵,弓兵,水军,极兵,玄兵

function calculateMovePower(person: PersonType): number {
  let armyType = getArmyType(person);
  let move = ARMY_MOVE_BASE[armyType];
  
  // 加上装备加成
  for (let equip of person.equip) {
    if (equip > 0) {
      let tool = getTool(equip);
      move += tool.move;
    }
  }
  
  // 最大移动力8
  return Math.min(move, 8);
}
```

---

## 三、行军路径算法

### 3.1 核心算法概述

使用改进的A*算法计算行军路径，考虑地形阻力和敌方阻挡。

### 3.2 地形阻力映射

```typescript
// 不同兵种在不同地形的阻力值
const TERRAIN_RESISTANCE = [
  // 骑兵 [草地,平原,山地,森林,村庄,城池,营寨,河流]
  [2, 1, 4, 4, 2, 4, 3, 5],
  // 步兵
  [2, 1, 2, 2, 2, 3, 2, 4],
  // 弓兵
  [2, 1, 3, 2, 2, 3, 2, 4],
  // 水军
  [2, 1, 3, 2, 2, 3, 2, 1],
  // 极兵
  [2, 1, 2, 2, 2, 2, 2, 3],
  // 玄兵
  [2, 1, 2, 2, 2, 3, 2, 4]
];
```

### 3.3 路径计算流程

```typescript
function calculateMovePath(
  generalIndex: number,
  mapData: number[],
  genPositions: JLPOS[]
): PathResult {
  let gen = genPositions[generalIndex];
  let person = getPerson(gen.personId);
  let armyType = getArmyType(person);
  
  // 1. 初始化15x15的路径计算区域
  let pathGrid = new Array(15 * 15).fill(0xFF); // 0xFF = 不可达
  
  // 2. 映射地形阻力
  for (let y = 0; y < 15; y++) {
    for (let x = 0; x < 15; x++) {
      let mapX = gen.x - 7 + x;
      let mapY = gen.y - 7 + y;
      
      if (isValidPosition(mapX, mapY)) {
        let terrain = getTerrain(mapX, mapY);
        pathGrid[y * 15 + x] = TERRAIN_RESISTANCE[armyType][terrain];
      }
    }
  }
  
  // 3. 设置敌方阻挡
  setEnemyBlock(generalIndex, genPositions, pathGrid);
  
  // 4. 设置友方阻挡
  setAllyBlock(generalIndex, genPositions, pathGrid);
  
  // 5. 使用BFS展开路径树
  let startX = 7;
  let startY = 7;
  let movePower = gen.move;
  pathGrid[startY * 15 + startX] = movePower; // 起始点设为移动力值
  
  // BFS队列
  let queue = [{ x: startX, y: startY, power: movePower }];
  let visited = new Set();
  
  while (queue.length > 0) {
    let current = queue.shift();
    let directions = [
      { dx: 0, dy: -1 }, // 上
      { dx: 0, dy: 1 },  // 下
      { dx: -1, dy: 0 }, // 左
      { dx: 1, dy: 0 }   // 右
    ];
    
    for (let dir of directions) {
      let newX = current.x + dir.dx;
      let newY = current.y + dir.dy;
      
      if (newX < 0 || newX >= 15 || newY < 0 || newY >= 15) continue;
      
      let index = newY * 15 + newX;
      let resistance = pathGrid[index];
      
      if (resistance >= 0x80) continue; // 不可通过
      
      let newPower = current.power - resistance + 0x80; // 0x80是基准值
      
      if (newPower > 0 && newPower > (pathGrid[index] & 0x7F)) {
        pathGrid[index] = newPower;
        queue.push({ x: newX, y: newY, power: newPower });
      }
    }
  }
  
  return { pathGrid, offsetX: gen.x - 7, offsetY: gen.y - 7 };
}
```

### 3.4 阻挡点设置

**敌方阻挡**：
```typescript
function setEnemyBlock(
  selfIndex: number,
  genPositions: JLPOS[],
  pathGrid: number[]
): void {
  let isPlayer = selfIndex < 10;
  let enemyStart = isPlayer ? 10 : 0;
  let enemyEnd = isPlayer ? 20 : 10;
  
  for (let i = enemyStart; i < enemyEnd; i++) {
    let enemy = genPositions[i];
    if (enemy.state === STATE_DEAD) continue;
    
    let localX = enemy.x - (genPositions[selfIndex].x - 7);
    let localY = enemy.y - (genPositions[selfIndex].y - 7);
    
    if (localX >= 0 && localX < 15 && localY >= 0 && localY < 15) {
      // 敌方所在格设为不可通过
      pathGrid[localY * 15 + localX] = 0xFE;
      
      // 周围4格设为待激活点（靠近后可攻击）
      if (localX > 0) pathGrid[localY * 15 + (localX - 1)] |= 0x20;
      if (localX < 14) pathGrid[localY * 15 + (localX + 1)] |= 0x20;
      if (localY > 0) pathGrid[(localY - 1) * 15 + localX] |= 0x20;
      if (localY < 14) pathGrid[(localY + 1) * 15 + localX] |= 0x20;
    }
  }
}
```

**友方阻挡**：
```typescript
function setAllyBlock(
  selfIndex: number,
  genPositions: JLPOS[],
  pathGrid: number[]
): void {
  let isPlayer = selfIndex < 10;
  let allyStart = isPlayer ? 0 : 10;
  let allyEnd = isPlayer ? 10 : 20;
  
  for (let i = allyStart; i < allyEnd; i++) {
    if (i === selfIndex) continue;
    
    let ally = genPositions[i];
    if (ally.state === STATE_DEAD) continue;
    
    let localX = ally.x - (genPositions[selfIndex].x - 7);
    let localY = ally.y - (genPositions[selfIndex].y - 7);
    
    if (localX >= 0 && localX < 15 && localY >= 0 && localY < 15) {
      // 友方所在格设为不可通过
      pathGrid[localY * 15 + localX] = 0xFE;
    }
  }
}
```

---

## 四、战斗行动系统

### 4.1 行动命令类型

| 命令 | ID | 说明 |
|------|-----|------|
| 攻击 | 0 | 普通攻击 |
| 计谋 | 1 | 使用技能 |
| 查看 | 2 | 查看战场信息 |
| 休息 | 3 | 结束回合 |

### 4.2 攻击系统

**攻击范围**：
- 基础攻击范围：5x5区域
- 不同兵种有不同攻击范围
- 部分武器可以扩展攻击范围

**攻击力计算**：
```typescript
const ATK_MODULUS = [1.0, 1.2, 0.9, 0.8, 1.3, 0.4]; // 各兵种攻击系数

defunction calculateAttack(person: PersonType): number {
  let armyType = getArmyType(person);
  let ratio = person.force; // 默认使用武力
  
  // 如果启用自定义比例
  if (g_engineConfig.enableCustomRatio) {
    ratio = person.iq * g_engineConfig.ratioOfAttToIQ / 10 +
            person.force * g_engineConfig.ratioOfAttToForce / 10 +
            person.age * g_engineConfig.ratioOfAttToAge / 10;
  }
  
  // 攻击力 = 属性比例 * (等级 + 10) * 兵种系数
  let attack = ratio * (person.level + 10) * ATK_MODULUS[armyType];
  
  // 应用地形修正
  let terrainMod = getTerrainModifier(person, 'attack');
  attack = applyTerrainModifier(attack, terrainMod);
  
  return Math.floor(attack);
}
```

**防御力计算**：
```typescript
const DEF_MODULUS = [0.7, 1.2, 1.0, 1.1, 1.2, 0.6]; // 各兵种防御系数

function calculateDefense(person: PersonType): number {
  let armyType = getArmyType(person);
  let ratio = person.iq; // 默认使用智力
  
  // 如果启用自定义比例
  if (g_engineConfig.enableCustomRatio) {
    ratio = person.iq * g_engineConfig.ratioOfDefenceToIQ / 10 +
            person.force * g_engineConfig.ratioOfDefenceToForce / 10 +
            person.age * g_engineConfig.ratioOfDefenceToAge / 10;
  }
  
  // 防御力 = 属性比例 * (等级 + 10) * 兵种系数
  let defense = ratio * (person.level + 10) * DEF_MODULUS[armyType];
  
  // 应用地形防御加成
  const TERRAIN_DEF_MOD = [1.0, 1.0, 1.3, 1.15, 1.1, 1.5, 1.2, 0.8];
  let terrain = getPersonTerrain(person);
  defense *= TERRAIN_DEF_MOD[terrain];
  
  return Math.floor(defense);
}
```

**伤害计算**：
```typescript
// 兵种相克矩阵 [攻击方][防守方]
const SUBDUE_MATRIX = [
  [1.0, 1.2, 0.8, 1.0, 0.7, 1.3], // 骑兵攻击
  [0.8, 1.0, 1.2, 1.0, 0.6, 1.2], // 步兵攻击
  [1.2, 0.8, 1.0, 1.0, 1.1, 1.2], // 弓兵攻击
  [1.0, 1.0, 1.0, 1.0, 1.0, 1.0], // 水军攻击
  [1.1, 1.3, 0.9, 1.0, 1.0, 1.5], // 极兵攻击
  [0.6, 0.6, 0.6, 0.6, 0.6, 0.6]  // 玄兵攻击
];

function calculateDamage(
  attacker: PersonType,
  defender: PersonType
): number {
  let at = calculateAttack(attacker);
  let df = calculateDefense(defender);
  let attackerArmy = getArmyType(attacker);
  let defenderArmy = getArmyType(defender);
  
  // 基础伤害 = (攻击/防御) * 兵力/8
  let baseDamage = (at / df) * (attacker.arms / 8);
  
  // 应用兵种相克
  let mod = SUBDUE_MATRIX[attackerArmy][defenderArmy];
  let damage = baseDamage * mod;
  
  // +10防止平局
  return Math.floor(damage) + 10;
}
```

---

## 五、技能系统

### 5.1 技能获取

每个武将可以学会的技能包括：
1. **特有技能**：武将专属技能
2. **君主技能**：君主专属的特殊技能
3. **兵种技能**：根据兵种和等级学会的技能

```typescript
function getSkillList(person: PersonType): number[] {
  let skills = [];
  
  // 1. 特有技能
  let specialSkill = getSpecialSkill(person.id);
  if (specialSkill > 0) {
    skills.push(specialSkill);
  }
  
  // 2. 君主技能
  if (person.belong === person.id + 1) {
    skills.push(30); // 天变技能
  }
  
  // 3. 兵种技能
  let armyType = getArmyType(person);
  let armySkills = getArmySkills(armyType);
  let skillCount = Math.floor(armySkills.length * person.level / 21) + 1;
  
  for (let i = 0; i < skillCount && i < armySkills.length; i++) {
    skills.push(armySkills[i]);
  }
  
  return skills;
}
```

### 5.2 各兵种技能数量

| 兵种 | 技能数量 |
|------|----------|
| 骑兵 | 3 |
| 步兵 | 4 |
| 弓兵 | 3 |
| 水军 | 3 |
| 极兵 | 4 |
| 玄兵 | 9 |

### 5.3 技能效果定义

```typescript
interface SkillEffect {
  aim: number;            // 施展目标 0=敌方, 1=我方
  state: number;          // 对目标状态的影响
  power: number;          // 对兵力的基本伤害
  destroy: number;        // 对粮草的基本伤害
  useMp: number;          // 消耗技能点
  weather: number[];      // 天气效果 [5] 百分比
  eland: number[];        // 敌人地形效果 [8] 百分比
  oland: number[];        // 我方地形效果 [8] 百分比
  earm: number[];         // 敌人兵种效果 [6] 百分比
}
```

### 5.4 技能使用判定

```typescript
function canUseSkill(
  skillId: number,
  person: PersonType,
  genPos: JLPOS
): boolean {
  let skill = getSkill(skillId);
  
  // 1. 检查技能点
  if (genPos.mp < skill.effect.useMp) {
    return false;
  }
  
  // 2. 检查地形
  let terrain = getPersonTerrain(person);
  if (skill.effect.oland[terrain] === 0) {
    return false;
  }
  
  // 3. 检查天气
  let weather = getCurrentWeather();
  if (skill.effect.weather[weather - 1] === 0) {
    return false;
  }
  
  return true;
}
```

### 5.5 技能伤害计算

```typescript
function calculateSkillDamage(
  skillId: number,
  caster: PersonType,
  target: PersonType
): SkillDamage {
  let skill = getSkill(skillId);
  let effect = skill.effect;
  
  // 基础伤害
  let armsDamage = effect.power;
  let provDamage = effect.destroy;
  
  // 应用天气修正
  let weather = getCurrentWeather();
  armsDamage *= effect.weather[weather - 1] / 100;
  provDamage *= effect.weather[weather - 1] / 100;
  
  // 应用目标兵种修正
  let targetArmy = getArmyType(target);
  armsDamage *= effect.earm[targetArmy] / 100;
  
  // 应用目标地形修正
  let targetTerrain = getPersonTerrain(target);
  armsDamage *= effect.eland[targetTerrain] / 100;
  
  // 应用施法者地形修正
  let casterTerrain = getPersonTerrain(caster);
  armsDamage *= effect.oland[casterTerrain] / 100;
  
  return {
    armsDamage: Math.floor(armsDamage),
    provDamage: Math.floor(provDamage),
    stateEffect: effect.state
  };
}
```

---

## 六、天气系统

### 6.1 天气类型

| 编号 | 天气 | 效果 |
|------|------|------|
| 1 | 晴 | 无影响 |
| 2 | 阴 | 部分技能增强 |
| 3 | 风 | 火系技能增强 |
| 4 | 雨 | 火系技能削弱 |
| 5 | 冰雹 | 全员受到伤害 |

### 6.2 天气对技能的影响表

| 技能 | 晴 | 阴 | 风 | 雨 | 冰雹 |
|------|-----|-----|-----|-----|------|
| 火攻 | 100% | 110% | 130% | 50% | 80% |
| 水淹 | 100% | 110% | 80% | 130% | 120% |
| 滚木 | 100% | 100% | 90% | 70% | 80% |
| 落石 | 100% | 100% | 100% | 90% | 110% |
| 其他 | 100% | 100% | 100% | 100% | 90% |

**说明**：
- 火系技能（火攻）在风天增强30%，雨天削弱50%
- 水系技能（水淹）在雨天增强30%，风天削弱20%
- 所有技能在冰雹天略微削弱（90%）

### 6.3 天气变换

```typescript
function changeWeather(): void {
  // 每回合有概率改变天气
  let roll = Math.random() * 100;
  
  if (roll < 20) {
    // 20%概率改变
    let newWeather = Math.floor(Math.random() * 5) + 1;
    setCurrentWeather(newWeather);
  }
}
```

---

## 七、粮草消耗系统

### 7.1 战场粮草消耗

```typescript
function calculateProvenderConsumption(armyCount: number): number {
  // 基础比例：每3个士兵每天消耗1份粮草
  let ratio = g_engineConfig.ratioOfFoodToArmsPerDay || 3;
  return Math.floor(Math.sqrt(armyCount) / ratio);
}

function consumeProvender(): void {
  // 计算双方兵力
  let playerArms = calculateTotalArms(0, 10);  // 0-9是玩家
  let enemyArms = calculateTotalArms(10, 20);  // 10-19是敌人
  
  // 计算消耗
  let playerConsumption = calculateProvenderConsumption(playerArms);
  let enemyConsumption = calculateProvenderConsumption(enemyArms);
  
  // 应用消耗
  g_battleParams.mProvender = Math.max(0, g_battleParams.mProvender - playerConsumption);
  g_battleParams.eProvender = Math.max(0, g_battleParams.eProvender - enemyConsumption);
  
  // 检查耗尽
  if (g_battleParams.mProvender === 0) {
    endBattle(RESULT_LOSE, '粮草耗尽');
  }
  if (g_battleParams.eProvender === 0) {
    endBattle(RESULT_WIN, '敌方粮草耗尽');
  }
}
```

---

## 八、战斗AI系统

### 8.1 AI决策流程

```typescript
function aiTurn(): void {
  // 1. 获取所有可行动的AI武将
  let availableGenerals = getAvailableAIGenerals();
  
  for (let gen of availableGenerals) {
    // 2. 选择最近的敌人作为目标方向
    let target = findNearestEnemy(gen);
    
    // 3. 计算移动路径
    calculateMovePath(gen.index);
    
    // 4. 决定移动位置
    let movePos = decideMovePosition(gen, target);
    moveGeneral(gen.index, movePos.x, movePos.y);
    
    // 5. 决定行动
    let action = decideAction(gen, target);
    executeAction(gen.index, action);
  }
}
```

### 8.2 AI移动策略

```typescript
function decideMovePosition(gen: GeneralInfo, target: GeneralInfo): Position {
  let bestPos = { x: gen.x, y: gen.y };
  let bestScore = -9999;
  
  // 遍历所有可移动位置
  for (let y = 0; y < 15; y++) {
    for (let x = 0; x < 15; x++) {
      if (canMoveTo(x, y)) {
        let score = evaluatePosition(x, y, gen, target);
        if (score > bestScore) {
          bestScore = score;
          bestPos = { x: x + g_pathOffsetX, y: y + g_pathOffsetY };
        }
      }
    }
  }
  
  return bestPos;
}

function evaluatePosition(x: number, y: number, gen: GeneralInfo, target: GeneralInfo): number {
  let score = 0;
  let terrain = getTerrain(x, y);
  
  // 1. 距离目标的距离（越近越好）
  let distToTarget = Math.abs(x - target.x) + Math.abs(y - target.y);
  score -= distToTarget * 10;
  
  // 2. 地形防御加成
  const TERRAIN_BONUS = [0, 0, 20, 15, 10, 50, 20, -20];
  score += TERRAIN_BONUS[terrain];
  
  // 3. 如果是进攻模式且能进城
  if (g_battleParams.mode === MODE_ATTACK && terrain === TERRAIN_CITY) {
    score += 1000;
  }
  
  // 4. 攻击范围内有敌人的加分
  if (canAttackFrom(x, y, target)) {
    score += 50;
  }
  
  return score;
}
```

### 8.3 AI行动策略

```typescript
function decideAction(gen: GeneralInfo, target: GeneralInfo): Action {
  // 策略1：尝试使用技能
  if (tryUseSkill(gen)) {
    return { type: ACTION_SKILL, skillId: selectBestSkill(gen) };
  }
  
  // 策略2：尝试攻击
  if (canAttack(gen, target)) {
    return { type: ACTION_ATTACK, target: target.index };
  }
  
  // 策略3：休息
  return { type: ACTION_REST };
}

function tryUseSkill(gen: GeneralInfo): boolean {
  // 如果处于禁咒状态，无法使用
  if (gen.state === STATE_JINZHOU) return false;
  
  // 获取可用技能
  let skills = getAvailableSkills(gen);
  if (skills.length === 0) return false;
  
  // 根据条件选择技能
  // 智力高的武将更倾向使用技能
  let person = getPerson(gen.personId);
  let useSkillRoll = Math.random() * 150;
  if (useSkillRoll > person.iq) return false;
  
  // 兵力少时更倾向使用技能（玄兵除外）
  if (getArmyType(person) !== ARMY_XUANBING) {
    let maxArms = calculateMaxArms(person);
    let armsRatio = person.arms / (maxArms * 1.5);
    if (Math.random() > armsRatio) return false;
  }
  
  return true;
}
```

---

## 九、经验与升级

### 9.1 经验获取

```typescript
const MAX_EXP = 100; // 满100升级

function gainExperience(person: PersonType, exp: number): void {
  if (g_engineConfig.disableExpGrowing) return;
  
  person.experience += exp;
  
  // 检查升级
  while (person.experience >= MAX_EXP) {
    person.experience -= MAX_EXP;
    levelUp(person);
  }
}
```

### 9.2 升级效果

```typescript
function levelUp(person: PersonType): void {
  if (person.level >= g_engineConfig.maxLevel) return;
  
  person.level++;
  
  // 提升属性
  person.force += Math.random() > 0.5 ? 1 : 0;
  person.iq += Math.random() > 0.5 ? 1 : 0;
  
  // 恢复状态
  person.thew = 100;
  
  // 显示升级提示
  showLevelUpAnimation(person.id);
}
```

---

*文档版本：1.0*  
*创建日期：2026-02-10*
