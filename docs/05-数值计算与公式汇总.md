# 三国霸业 - 数值计算与公式汇总文档

## 文档说明

本文档汇总《三国霸业》中所有的数值计算公式、概率算法和平衡参数，便于重构时准确复刻游戏数值系统。

---

## 一、武将属性计算公式

### 1.1 带兵上限计算

**默认公式**：
```typescript
function calculateMaxArms(person: PersonType): number {
  let arms = 0;
  arms += person.level * 100;
  arms += person.force * 10;
  arms += person.iq * 10;
  return Math.min(arms, 0xFFFE); // 最大65534
}
```

**自定义公式**（启用enableCustomRatio时）：
```typescript
function calculateMaxArmsCustom(person: PersonType): number {
  let arms = 0;
  arms += person.level * config.ratioOfArmsToLevel;
  arms += person.age * config.ratioOfArmsToAge;
  arms += person.force * config.ratioOfArmsToForce;
  arms += person.iq * config.ratioOfArmsToIQ;
  return Math.min(arms, 0xFFFE);
}
```

### 1.2 攻击力计算

**默认公式**：
```typescript
function calculateAttack(person: PersonType): number {
  let armyType = getArmyType(person);
  const ATK_MODULUS = [1.0, 1.2, 0.9, 0.8, 1.3, 0.4];
  
  let attack = person.force * (person.level + 10) * ATK_MODULUS[armyType];
  return Math.floor(attack);
}
```

**自定义公式**：
```typescript
function calculateAttackCustom(person: PersonType): number {
  let armyType = getArmyType(person);
  const ATK_MODULUS = [1.0, 1.2, 0.9, 0.8, 1.3, 0.4];
  
  let ratio = 0;
  ratio += person.iq * config.ratioOfAttToIQ / 10;
  ratio += person.force * config.ratioOfAttToForce / 10;
  ratio += person.age * config.ratioOfAttToAge / 10;
  
  let attack = ratio * (person.level + 10) * ATK_MODULUS[armyType];
  return Math.floor(attack);
}
```

### 1.3 防御力计算

**默认公式**：
```typescript
function calculateDefense(person: PersonType): number {
  let armyType = getArmyType(person);
  const DEF_MODULUS = [0.7, 1.2, 1.0, 1.1, 1.2, 0.6];
  
  let defense = person.iq * (person.level + 10) * DEF_MODULUS[armyType];
  return Math.floor(defense);
}
```

**自定义公式**：
```typescript
function calculateDefenseCustom(person: PersonType): number {
  let armyType = getArmyType(person);
  const DEF_MODULUS = [0.7, 1.2, 1.0, 1.1, 1.2, 0.6];
  const TERRAIN_DEF_MOD = [1.0, 1.0, 1.3, 1.15, 1.1, 1.5, 1.2, 0.8];
  
  let ratio = 0;
  ratio += person.iq * config.ratioOfDefenceToIQ / 10;
  ratio += person.force * config.ratioOfDefenceToForce / 10;
  ratio += person.age * config.ratioOfDefenceToAge / 10;
  
  let defense = ratio * (person.level + 10) * DEF_MODULUS[armyType];
  
  // 应用地形加成
  let terrain = getPersonTerrain(person);
  defense *= TERRAIN_DEF_MOD[terrain];
  
  return Math.floor(defense);
}
```

### 1.4 战斗HP计算

```typescript
function calculateBattleHP(person: PersonType): number {
  // HP = (武力 * 0.8 + 智力 * 0.3 + 等级) * 体力 / 100
  let baseHP = (person.force * 0.8 + person.iq * 0.3 + person.level);
  return Math.floor(baseHP * person.thew / 100);
}
```

### 1.5 战斗MP计算

```typescript
function calculateBattleMP(person: PersonType): number {
  // MP = (智力 * 0.8 + √武力 / 2 + 等级) * 体力 / 100
  let baseMP = (person.iq * 0.8 + Math.sqrt(person.force) / 2 + person.level);
  return Math.floor(baseMP * person.thew / 100);
}
```

### 1.6 移动力计算

```typescript
const ARMY_MOVE_BASE = [5, 4, 4, 5, 6, 3]; // 骑兵,步兵,弓兵,水军,极兵,玄兵

function calculateMovePower(person: PersonType): number {
  let armyType = getArmyType(person);
  let move = ARMY_MOVE_BASE[armyType];
  
  // 装备加成
  for (let equip of person.equip) {
    if (equip > 0) {
      let tool = getTool(equip);
      move += tool.move;
    }
  }
  
  // 状态影响
  if (person.state === STATE_DINGSHEN) {
    move = 1; // 定身状态
  }
  
  return Math.min(move, 8); // 最大移动力8
}
```

---

## 二、战斗伤害计算公式

### 2.1 基础伤害公式

```typescript
const SUBDUE_MATRIX = [
  //      骑   步   弓   水   极   玄
  [1.0, 1.2, 0.8, 1.0, 0.7, 1.3], // 骑兵攻击
  [0.8, 1.0, 1.2, 1.0, 0.6, 1.2], // 步兵攻击
  [1.2, 0.8, 1.0, 1.0, 1.1, 1.2], // 弓兵攻击
  [1.0, 1.0, 1.0, 1.0, 1.0, 1.0], // 水军攻击
  [1.1, 1.3, 0.9, 1.0, 1.0, 1.5], // 极兵攻击
  [0.6, 0.6, 0.6, 0.6, 0.6, 0.6]  // 玄兵攻击
];

function calculateDamage(attacker: PersonType, defender: PersonType): number {
  let at = calculateAttack(attacker);
  let df = calculateDefense(defender);
  let attackerArmy = getArmyType(attacker);
  let defenderArmy = getArmyType(defender);
  
  // 基础伤害 = (攻击/防御) * 兵力/8
  let baseDamage = (at / df) * (attacker.arms / 8);
  
  // 应用兵种相克
  let mod = SUBDUE_MATRIX[attackerArmy][defenderArmy];
  let damage = baseDamage * mod;
  
  // +10防止平局
  return Math.floor(damage) + 10;
}
```

### 2.2 地形修正计算

```typescript
// 地形对攻击力的修正
function applyTerrainModifierAttack(attack: number, modifier: number): number {
  if (modifier >= 0 && modifier <= 3) {
    // 原版计算：右移
    return attack >> modifier;
  } else {
    // 新版计算：百分比
    if (modifier > 99) modifier = 99;
    if (modifier < -99) modifier = -99;
    return attack - (attack * modifier / 100);
  }
}
```

### 2.3 技能伤害计算

```typescript
function calculateSkillDamage(
  skill: Skill,
  caster: PersonType,
  target: PersonType
): SkillDamageResult {
  let effect = skill.effect;
  
  // 基础伤害
  let armsDamage = effect.power;
  let provDamage = effect.destroy;
  
  // 天气修正 (0-100%)
  let weather = getCurrentWeather();
  let weatherMod = effect.weather[weather - 1] / 100;
  armsDamage *= weatherMod;
  provDamage *= weatherMod;
  
  // 目标兵种修正 (0-100%)
  let targetArmy = getArmyType(target);
  let armyMod = effect.earm[targetArmy] / 100;
  armsDamage *= armyMod;
  
  // 目标地形修正 (0-100%)
  let targetTerrain = getPersonTerrain(target);
  let targetTerrainMod = effect.eland[targetTerrain] / 100;
  armsDamage *= targetTerrainMod;
  
  // 施法者地形修正 (0-100%)
  let casterTerrain = getPersonTerrain(caster);
  let casterTerrainMod = effect.oland[casterTerrain] / 100;
  armsDamage *= casterTerrainMod;
  
  return {
    armsDamage: Math.floor(armsDamage),
    provDamage: Math.floor(provDamage),
    stateEffect: effect.state
  };
}
```

---

## 三、外交成功率计算公式

### 3.1 招降成功率

```typescript
const SURRENDER_CHARACTER_MOD = {
  [CHARACTER_LOYALISM]: 5,   // 忠义
  [CHARACTER_IDEAL]: 20,     // 大志
  [CHARACTER_AVARICE]: 30,   // 贪财
  [CHARACTER_DREAD]: 60,     // 怕死
  [CHARACTER_TEMERITY]: 15   // 卤莽
};

function calculateSurrenderRate(
  executor: PersonType,
  target: PersonType
): number {
  // 基础成功率
  let baseRate = executor.iq - target.iq + 50;
  if (baseRate > 100) baseRate = 100;
  
  // 忠诚度检查 (>60无法招降)
  if (target.devotion > 60) return 0;
  
  // 计算最终成功率
  let charMod = SURRENDER_CHARACTER_MOD[target.character];
  let finalRate = baseRate / charMod;
  
  return Math.max(0, Math.min(100, finalRate));
}
```

### 3.2 离间成功率

```typescript
const ALIENATE_CHARACTER_MOD = {
  [CHARACTER_LOYALISM]: 5,   // 忠义
  [CHARACTER_IDEAL]: 30,     // 大志
  [CHARACTER_AVARICE]: 40,   // 贪财
  [CHARACTER_DREAD]: 30,     // 怕死
  [CHARACTER_TEMERITY]: 50   // 卤莽
};

function calculateAlienateRate(
  executor: PersonType,
  target: PersonType
): number {
  // 基础成功率
  let baseRate = executor.iq - target.iq + 50;
  
  // 随机判定智力差
  let roll1 = Math.random() * 100;
  if (roll1 > baseRate) return 0;
  
  // 忠诚度判定
  let roll2 = Math.random() * 100;
  if (roll2 < target.devotion) return 0;
  
  // 性格判定
  let charMod = ALIENATE_CHARACTER_MOD[target.character];
  let roll3 = Math.random() * 100;
  if (roll3 > charMod) return 0;
  
  return 1; // 成功
}
```

### 3.3 招揽成功率

```typescript
const CANVASS_CHARACTER_MOD = {
  [CHARACTER_LOYALISM]: 5,   // 忠义
  [CHARACTER_IDEAL]: 20,     // 大志
  [CHARACTER_AVARICE]: 30,   // 贪财
  [CHARACTER_DREAD]: 40,     // 怕死
  [CHARACTER_TEMERITY]: 15   // 卤莽
};

function calculateCanvassRate(
  executor: PersonType,
  target: PersonType
): number {
  // 智力差判定
  let iqDiff = executor.iq - target.iq;
  let roll1 = Math.random() * 100;
  if ((roll1 + 100) > (iqDiff + 100)) return 0;
  
  // 忠诚度判定
  let roll2 = Math.random() * 100;
  if (roll2 < target.devotion) return 0;
  
  // 性格判定
  let charMod = CANVASS_CHARACTER_MOD[target.character];
  let roll3 = Math.random() * 100;
  if (roll3 > charMod) return 0;
  
  return 1; // 成功
}
```

### 3.4 策反成功率

```typescript
const COUNTERESPIONAGE_CHARACTER_MOD = {
  [CHARACTER_LOYALISM]: 5,   // 忠义
  [CHARACTER_IDEAL]: 60,     // 大志 (最容易被策反)
  [CHARACTER_AVARICE]: 20,   // 贪财
  [CHARACTER_DREAD]: 10,     // 怕死
  [CHARACTER_TEMERITY]: 30   // 卤莽
};

function calculateCounterespionageRate(
  executor: PersonType,
  target: PersonType
): number {
  // 基础成功率
  let baseRate = executor.iq - target.iq + 50;
  if (baseRate > 100) baseRate = 100;
  
  // 智力判定
  let roll1 = Math.random() * 100;
  if (roll1 > baseRate) return 0;
  
  // 忠诚度判定
  let roll2 = Math.random() * 100;
  if (roll2 < target.devotion) return 0;
  
  // 性格判定
  let charMod = COUNTERESPIONAGE_CHARACTER_MOD[target.character];
  let roll3 = Math.random() * 100;
  if (roll3 > charMod) return 0;
  
  return 1; // 成功
}
```

### 3.5 劝降成功率

```typescript
const PERSUADE_CHARACTER_MOD = {
  [CHARACTER_PEACE]: 15,      // 和平
  [CHARACTER_JUSTICE]: 5,     // 大义
  [CHARACTER_DUPLICITY]: 20,  // 奸诈
  [CHARACTER_CRAZY]: 1,       // 狂人
  [CHARACTER_RASH]: 10        // 冒进
};

function calculateInduceRate(
  executor: PersonType,
  targetKing: PersonType
): number {
  // 检查城池数量条件
  let myCities = getKingCitys(executor.belong - 1).length;
  let targetCities = getKingCitys(targetKing.id).length;
  if (myCities < targetCities * 2) return 0;
  
  // 基础成功率
  let baseRate = executor.iq - targetKing.iq + 50;
  
  // 智力判定
  let roll1 = Math.random() * 100;
  if (roll1 > baseRate) return 0;
  
  // 性格判定
  let charMod = PERSUADE_CHARACTER_MOD[targetKing.character];
  let roll2 = Math.random() * 100;
  if (roll2 > charMod) return 0;
  
  return 1; // 成功
}
```

---

## 四、内政数值计算公式

### 4.1 开垦增量

```typescript
function calculateFarmingIncrease(person: PersonType): number {
  // 基础增量 = 10 + 随机(0 ~ 智力*2)
  let baseIncrease = 10 + Math.random() * (person.iq * 2);
  return Math.floor(baseIncrease);
}
```

### 4.2 招商增量

```typescript
function calculateCommerceIncrease(person: PersonType): number {
  // 基础增量 = 10 + 随机(0 ~ 智力*2)
  let baseIncrease = 10 + Math.random() * (person.iq * 2);
  return Math.floor(baseIncrease);
}
```

### 4.3 搜寻成功率

```typescript
function calculateSearchSuccessRate(person: PersonType): number {
  // 成功率 = 智力/150
  return person.iq / 150;
}
```

### 4.4 出巡民忠增量

```typescript
function calculateInspectionIncrease(person: PersonType): number {
  let baseIncrease = 5 + Math.random() * 10;
  
  // 君主身份加成
  if (person.belong === person.id + 1) {
    baseIncrease *= 1.5;
  }
  
  return Math.floor(baseIncrease);
}
```

### 4.5 掠夺收益

```typescript
function calculateDepredateGain(person: PersonType): { money: number, food: number } {
  let baseValue = person.iq + person.force;
  
  return {
    money: baseValue * 2,
    food: baseValue * 5
  };
}
```

---

## 五、资源计算公式

### 5.1 每月自动增长

```typescript
function monthlyResourceGrowth(city: CityType): void {
  // 粮食 = 农业/10
  let foodGrowth = city.farming / 10;
  city.food = Math.min(city.food + foodGrowth, MAX_FOOD);
  
  // 金钱 = 商业/10
  let moneyGrowth = city.commerce / 10;
  city.money = Math.min(city.money + moneyGrowth, MAX_MONEY);
  
  // 人口 = 当前人口 * 1%
  let popGrowth = Math.floor(city.population * 0.01);
  city.population = Math.min(city.population + popGrowth, city.populationLimit);
}
```

### 5.2 战场粮草消耗

```typescript
function calculateProvenderConsumption(armyCount: number): number {
  let ratio = config.ratioOfFoodToArmsPerDay || 3;
  return Math.floor(Math.sqrt(armyCount) / ratio);
}
```

### 5.3 城市粮草消耗（市政）

```typescript
function calculateCityProvenderConsumption(
  city: CityType
): number {
  let ratio = config.ratioOfFoodToArmsPerMouth || 50;
  let totalArms = getCityTotalArms(city.id);
  return Math.floor(totalArms / ratio);
}
```

### 5.4 征兵数量

```typescript
function calculateConscriptionAmount(city: CityType): number {
  // 基础 = 民忠 * 配置系数
  let baseAmount = city.peopleDevotion * config.armsPerDevotion;
  
  // 受限于后备兵力
  return Math.min(baseAmount, city.mothballArms);
}
```

### 5.5 交易价格

```typescript
function calculateExchangeRate(city: CityType, type: 'buy' | 'sell'): number {
  let baseRate = 10; // 10粮食 = 1金钱
  let commerceFactor = city.commerce / city.commerceLimit;
  let fluctuation = 0.8 + Math.random() * 0.4;
  
  if (type === 'buy') {
    return Math.floor(baseRate * (1 + commerceFactor * 0.5) * fluctuation * 1.1);
  } else {
    return Math.floor(baseRate * (1 + commerceFactor * 0.5) * fluctuation * 0.9);
  }
}
```

---

## 六、升级与经验系统

### 6.1 经验获取

```typescript
const MAX_EXP = 100;

function gainExperience(person: PersonType, exp: number): void {
  if (config.disableExpGrowing) return;
  
  person.experience += exp;
  
  while (person.experience >= MAX_EXP) {
    person.experience -= MAX_EXP;
    levelUp(person);
  }
}
```

### 6.2 战斗经验获取

```typescript
function calculateBattleExperience(
  damage: number,
  isKilling: boolean
): number {
  let baseExp = damage / 100;
  if (isKilling) baseExp *= 2;
  return Math.floor(baseExp);
}
```

### 6.3 升级属性增长

```typescript
function levelUp(person: PersonType): void {
  if (person.level >= config.maxLevel) return;
  
  person.level++;
  
  // 武力增长 (50%概率+1)
  if (Math.random() > 0.5) person.force++;
  
  // 智力增长 (50%概率+1)
  if (Math.random() > 0.5) person.iq++;
  
  // 体力恢复
  person.thew = 100;
}
```

---

## 七、随机事件概率

### 7.1 灾害触发概率

```typescript
function checkCalamity(city: CityType): boolean {
  // 概率 = 100 - 防灾值
  let probability = 100 - city.avoidCalamity;
  let roll = Math.random() * 100;
  return roll < probability;
}
```

### 7.2 搜寻事件分布

```typescript
const SEARCH_EVENT_DISTRIBUTION = {
  nothing: 0.25,    // 一无所获
  person: 0.25,     // 发现人才
  tool: 0.25,       // 发现道具
  money: 0.125,     // 获得金钱
  food: 0.125       // 获得粮食
};
```

### 7.3 输送成功率

```typescript
const TRANSPORT_SUCCESS_RATE = 0.80; // 80%成功率
```

---

## 八、默认配置参数表

### 8.1 引擎配置默认值

```typescript
const DEFAULT_CONFIG = {
  // 数值比例
  armsPerMoney: 10,
  armsPerDevotion: 20,
  maxLevel: 20,
  
  // 带兵量计算
  ratioOfArmsToLevel: 100,
  ratioOfArmsToAge: 0,
  ratioOfArmsToIQ: 10,
  ratioOfArmsToForce: 10,
  
  // 攻击力计算
  ratioOfAttToForce: 10,
  ratioOfAttToIQ: 0,
  ratioOfAttToAge: 0,
  
  // 防御力计算
  ratioOfDefenceToForce: 0,
  ratioOfDefenceToIQ: 10,
  ratioOfDefenceToAge: 0,
  
  // 粮草消耗
  ratioOfFoodToArmsPerMouth: 50,
  ratioOfFoodToArmsPerDay: 3,
  
  // AI配置
  aiLevelUpSpeed: 0,
  aiDefenceMode: 0,
  aiAttackMethod: 0,
  
  // 功能开关
  enableCustomRatio: false,
  enableScript: false,
  disableExpGrowing: false,
  disableAgeGrow: false,
  disableSL: false
};
```

### 8.2 城市数量配置

```typescript
const DEFAULT_CITY_CONFIG = {
  citiesCount: 38,        // 默认38座城
  cityMapWidth: 12,       // 战略地图宽
  cityMapHeight: 9        // 战略地图高
};
```

---

## 九、常量汇总表

### 9.1 战斗常量

| 常量名 | 值 | 说明 |
|--------|-----|------|
| FGT_PLAMAX | 10 | 每方最大将领数 |
| FGT_EXPMAX | 100 | 最大经验值 |
| MAX_LEVEL | 20 | 最大等级 |
| MOV_RSTD | 0x80 | 地形阻力基准值 |
| MOV_NOT | 0xFE | 不可移动点 |
| MOV_OVER | 0xFF | 超出地图范围 |

### 9.2 状态常量

| 常量名 | 值 | 说明 |
|--------|-----|------|
| STATE_ZC | 0 | 正常 |
| STATE_HL | 1 | 混乱 |
| STATE_JZ | 2 | 禁咒 |
| STATE_DS | 3 | 定身 |
| STATE_QM | 4 | 奇门 |
| STATE_DJ | 5 | 遁甲 |
| STATE_SZ | 6 | 石阵 |
| STATE_QZ | 7 | 潜踪 |
| STATE_SW | 8 | 死亡 |

### 9.3 地形常量

| 常量名 | 值 |
|--------|-----|
| TERRAIN_LEA | 0 | 草地 |
| TERRAIN_DENE | 1 | 平原 |
| TERRAIN_HILL | 2 | 山地 |
| TERRAIN_WOOD | 3 | 森林 |
| TERRAIN_THORP | 4 | 村庄 |
| TERRAIN_CITY | 5 | 城池 |
| TERRAIN_TENT | 6 | 营寨 |
| TERRAIN_RIVER | 7 | 河流 |

---

*文档版本：1.0*  
*创建日期：2026-02-10*
